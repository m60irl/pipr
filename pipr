#!/usr/bin/env bash
# pipr: Pipe ANY supported livestream/video to an RTMP endpoint using yt-dlp and ffmpeg.
# Usage:
#   pipr [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] \
#        [--audio-bitrate <abitrate>] [--audio-rate <arate>] [--gop <frames>] \
#        [--keyframe-interval <seconds|frames>] [--fps <rate>] \
#        [--analyzeduration <value>] [--probesize <value>] \
#        [--ytdlp-format <fmt>] [--ytdlp-arg <arg> ...] \
#        "<source_url>" "<rtmp_endpoint>"
# Examples:
#   pipr "https://www.youtube.com/watch?v=XXXXX" "rtmp://your-endpoint/live/stream_key"
#   pipr --force-encoding --encoder libx264 --bitrate 4500k --preset veryfast \
#        "https://www.twitch.tv/<channel>" "rtmp://your-endpoint/live/key"
#   pipr -v --preset fast --encoder h264_nvenc --audio-bitrate 160k --audio-rate 48k \
#        --keyframe-interval 2s --fps 60 "https://www.example.com/video" "rtmp://your-endpoint/live/key"

set -euo pipefail -E

#####################
# Logging Functions #
#####################
LOGFILE="pipr.log"
log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "$LOGFILE"
}
err() {
  log "ERROR: $*"
  exit 1
}

# ERR trap for error tracing
trap 'log "ERROR: Command failed at line $LINENO with exit code $? (command: $BASH_COMMAND)"; exit 1' ERR

# Signal handling for graceful shutdown
cleanup() {
  log "[pipr] Received shutdown signal. Terminating child processes..."
  kill 0 2>/dev/null || true
  exit 1
}
trap cleanup INT TERM

################################
# Privacy/utility helper funcs #
################################
host_from_url() {
  # Prints only the host of a URL (scheme-agnostic)
  # Example: https://example.com/path?a=b -> example.com
  local url="$1"
  echo "$url" | sed -E 's~https?://([^/]+).*~\1~' | tr -d '\n'
}

mask_rtmp() {
  # Masks the last path segment (e.g., stream key) but keeps a short tail
  # Example: rtmp://server/app/abcdef123 -> rtmp://server/app/***e123
  local url="$1"
  local no_query="${url%%\?*}"
  local base="${no_query%/*}"
  local key="${no_query##*/}"
  if [[ -z "$key" || "$base" == "$no_query" ]]; then
    echo "${no_query%/}/***"
    return
  fi
  local tail=""
  if [[ ${#key} -gt 4 ]]; then
    tail="${key: -4}"
    echo "${base}/***${tail}"
  else
    echo "${base}/***"
  fi
}

# Sanitize tool stderr by masking RTMP endpoints and reducing HTTP(S) URLs to host-only
# Handles trailing quotes/punctuation so the masked output looks natural.
filter_stderr() {
  while IFS= read -r line; do
    local out="$line"
    while read -r token; do
      [[ -z "$token" ]] && continue
      local url="$token"
      # Trim common trailing punctuation and quotes from token to get the raw URL
      while :; do
        case "$url" in
          *\"|*,|*\)|*\]|*\>|*.|*\;|*:|*\') url="${url%?}" ;;
          *) break ;;
        esac
      done
      [[ -z "$url" ]] && continue
      local replacement=""
      if [[ "$url" =~ ^rtmps?:// ]]; then
        replacement="$(mask_rtmp "$url")"
      elif [[ "$url" =~ ^https?:// ]]; then
        local proto host
        proto="${url%%://*}"
        host="$(host_from_url "$url")"
        replacement="${proto}://${host}/..."
      fi
      if [[ -n "$replacement" ]]; then
        out=${out//"$url"/"$replacement"}
      fi
    done < <(grep -Eo '((rtmps?|https?)://[^[:space:]]+)' <<<"$line" || true)
    echo "$out"
  done
}

###############################
# Flags, Arguments and Defaults#
###############################
VERBOSE=0
FORCE_ENCODING=0
ENCODER="libx264"
VBITRATE=""
PRESET="veryfast"
ABITRATE=""   # e.g., 128k, 160k
ARATE=""      # e.g., 44100, 48k
GOP=""        # keyframe interval in frames
KEYINT=""     # keyframe interval in seconds (e.g., 2s) or frames (e.g., 120)
FPS=""        # optional, used to align -g with seconds-based keyframe interval
ANALYZEDURATION="20M"
PROBESIZE="100M"

# yt-dlp pass-through support
YTDLP_ARGS=()
YTDLP_FORMAT='bestvideo*+bestaudio/best'

print_help() {
  cat <<EOF
Usage: pipr [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] [--audio-bitrate <abitrate>] [--audio-rate <arate>] [--gop <frames>] [--keyframe-interval <value>] [--fps <rate>] [--analyzeduration <value>] [--probesize <value>] [--ytdlp-format <fmt>] [--ytdlp-arg <arg> ...] "<source_url>" "<rtmp_endpoint>"

Options:
  -v                         Verbose mode; mirror yt-dlp/ffmpeg output to terminal and log.
  --force-encoding           Skip stream copy and start with re-encoding.
  --encoder <name>           Video encoder for re-encode (default: libx264). Examples: libx264, h264_nvenc, hevc_videotoolbox.
  --bitrate <vbitrate>       Video bitrate for re-encode (e.g., 4500k). Default: encoder default.
  --preset <preset>          Encoder preset (default: veryfast). Examples: veryfast, fast, medium.
  --audio-bitrate <abitrate> Audio bitrate (e.g., 128k, 160k). Default: encoder default.
  --audio-rate <arate>       Audio sample rate (e.g., 44100, 48k). Default: source/default.
  --gop <frames>             GOP size (keyframe interval in frames). Applies -g <frames> and -sc_threshold 0.
  --keyframe-interval <v>    Keyframe interval in seconds (e.g., 2s) or frames (e.g., 120). Overrides --gop.
  --fps <rate>               When using a seconds-based interval, also set -g = seconds*fps for encoders that prefer it.
  --analyzeduration <value>  ffmpeg analyzeduration (default: 20M).
  --probesize <value>        ffmpeg probesize (default: 100M).
  --ytdlp-format <fmt>       yt-dlp format selector (default: bestvideo*+bestaudio/best).
  --ytdlp-arg <arg>          Additional yt-dlp argument (repeatable). Example: --ytdlp-arg "--cookies cookies.txt"
  -h, --help                 Show this help and exit.

Notes:
- Copy is attempted first unless --force-encoding is set. If copy fails, re-encoding is used with the above settings.
- Logs sanitize RTMP endpoints and reduce HTTP(S) URLs to host-only, but be cautious if sharing logs.
EOF
}

# Simple long-option parser
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v) VERBOSE=1; shift ;;
    --force-encoding) FORCE_ENCODING=1; shift ;;
    --encoder) [[ -n "${2-}" ]] || err "Missing value for $1"; ENCODER="$2"; shift 2 ;;
    --bitrate|--vb|--video-bitrate) [[ -n "${2-}" ]] || err "Missing value for $1"; VBITRATE="$2"; shift 2 ;;
    --preset) [[ -n "${2-}" ]] || err "Missing value for $1"; PRESET="$2"; shift 2 ;;
    --audio-bitrate|--ab) [[ -n "${2-}" ]] || err "Missing value for $1"; ABITRATE="$2"; shift 2 ;;
    --audio-rate|--ar) [[ -n "${2-}" ]] || err "Missing value for $1"; ARATE="$2"; shift 2 ;;
    --gop) [[ -n "${2-}" ]] || err "Missing value for $1"; GOP="$2"; shift 2 ;;
    --keyframe-interval|--keyint) [[ -n "${2-}" ]] || err "Missing value for $1"; KEYINT="$2"; shift 2 ;;
    --fps) [[ -n "${2-}" ]] || err "Missing value for $1"; FPS="$2"; shift 2 ;;
    --analyzeduration) [[ -n "${2-}" ]] || err "Missing value for $1"; ANALYZEDURATION="$2"; shift 2 ;;
    --probesize) [[ -n "${2-}" ]] || err "Missing value for $1"; PROBESIZE="$2"; shift 2 ;;
    --ytdlp-arg) [[ -n "${2-}" ]] || err "Missing value for $1"; YTDLP_ARGS+=( "$2" ); shift 2 ;;
    --ytdlp-format) [[ -n "${2-}" ]] || err "Missing value for $1"; YTDLP_FORMAT="$2"; shift 2 ;;
    -h|--help) print_help; exit 0 ;;
    --) shift; break ;;
    -*) err "Unknown option: $1" ;;
    *) break ;;
  esac
done

STREAM_URL="${1-}"
RTMP_ENDPOINT="${2-}"

if [[ -z "$STREAM_URL" || -z "$RTMP_ENDPOINT" ]]; then
  err "Usage: pipr [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] [--audio-bitrate <abitrate>] [--audio-rate <arate>] [--gop <frames>] [--keyframe-interval <value>] [--fps <rate>] [--analyzeduration <value>] [--probesize <value>] [--ytdlp-format <fmt>] [--ytdlp-arg <arg> ...] \"<source_url>\" \"<rtmp_endpoint>\""
fi

for cmd in yt-dlp ffmpeg; do
  if ! command -v "$cmd" &>/dev/null; then
    err "Required command '$cmd' not found. Please install it."
  fi
done

###################################
# Identify source domain for log  #
###################################
DOMAIN="$(host_from_url "$STREAM_URL")"
log "[pipr] Source domain detected: $DOMAIN"

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Force encoding enabled; stream copy attempt will be skipped."
fi
log "[pipr] Encoding settings: encoder=$ENCODER preset=$PRESET vbitrate=${VBITRATE:-default} abitrate=${ABITRATE:-default} arate=${ARATE:-default} gop=${GOP:-default} keyint=${KEYINT:-default} fps=${FPS:-default}"
log "[pipr] Buffering: analyzeduration=$ANALYZEDURATION probesize=$PROBESIZE"

#######################
# Get direct URL       #
#######################
log "[pipr] Getting media stream URL from yt-dlp for: $DOMAIN"
if [[ $VERBOSE -eq 1 ]]; then
  mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)) || err "[pipr] yt-dlp failed to get stream URL"
else
  mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr >>"$LOGFILE")) || err "[pipr] yt-dlp failed to get stream URL"
fi

if [[ ${#MEDIA_URLS[@]} -eq 0 ]]; then
  err "[pipr] No media URLs returned by yt-dlp"
fi

MEDIA_HOST="$(host_from_url "${MEDIA_URLS[0]}")"
MASKED_RTMP="$(mask_rtmp "$RTMP_ENDPOINT")"
log "[pipr] Resolved media host: $MEDIA_HOST"
log "[pipr] Streaming to RTMP endpoint: $MASKED_RTMP"

#########################################
# Build input args (multi-URL handling) #
#########################################
FFMPEG_INPUT_ARGS=(-hide_banner -analyzeduration "$ANALYZEDURATION" -probesize "$PROBESIZE")
MAP_ARGS=()
# Append per-input reconnect flags (for HTTP/S) and -i
for idx in "${!MEDIA_URLS[@]}"; do
  url="${MEDIA_URLS[$idx]}"
  if [[ "$url" =~ ^https?:// ]]; then
    FFMPEG_INPUT_ARGS+=( -reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 -rw_timeout 15000000 -http_persistent 0 )
  else
    # Apply -re only for non-HTTP(S) inputs (file/local)
    FFMPEG_INPUT_ARGS+=( -re )
  fi
  FFMPEG_INPUT_ARGS+=( -i "$url" )
  # Build stream mapping if we have 2 inputs (0=video, 1=audio)
  if [[ ${#MEDIA_URLS[@]} -ge 2 ]]; then
    if [[ $idx -eq 0 ]]; then MAP_ARGS+=( -map 0:v:0 ); fi
    if [[ $idx -eq 1 ]]; then MAP_ARGS+=( -map 1:a:0 ); fi
  fi
done

#########################################
# Streaming with ffmpeg + error fallback#
#########################################
run_ffmpeg_copy() {
  set +e
  if [[ $VERBOSE -eq 1 ]]; then
    ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)
  else
    ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr >>"$LOGFILE")
  fi
  local exit_code=$?
  set -e
  return $exit_code
}

run_ffmpeg_encode() {
  set +e
  local extra=()
  # Encoding-path compatibility defaults for RTMP/FLV
  extra+=( -pix_fmt yuv420p -ac 2 )
  # Bitrate and audio tuning
  if [[ -n "$VBITRATE" ]]; then
    extra+=( -b:v "$VBITRATE" -maxrate "$VBITRATE" -bufsize "$VBITRATE" )
  fi
  if [[ -n "$ABITRATE" ]]; then extra+=( -b:a "$ABITRATE" ); fi
  if [[ -n "$ARATE" ]]; then extra+=( -ar "$ARATE" ); fi
  # GOP / keyframe interval
  if [[ -n "$KEYINT" ]]; then
    local val="$KEYINT"
    if [[ "$val" =~ ^[0-9]+(\.[0-9]+)?s$ ]]; then
      local sec="${val%s}"
      extra+=( -sc_threshold 0 -force_key_frames "expr:gte(t,n_forced*${sec})" )
      if [[ -n "$FPS" && "$FPS" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        # Compute frames = round(sec * fps) using awk
        local gframes
        gframes=$(awk -v s="$sec" -v f="$FPS" 'BEGIN{printf "%d", s*f + 0.5}')
        if [[ "$gframes" -gt 0 ]]; then
          extra+=( -g "$gframes" -r "$FPS" -vsync cfr )
        fi
      fi
    elif [[ "$val" =~ ^[0-9]+$ ]]; then
      extra+=( -g "$val" -sc_threshold 0 )
    else
      log "[pipr] Warning: invalid --keyframe-interval value '$val'; ignoring"
    fi
  elif [[ -n "$GOP" ]]; then
    extra+=( -g "$GOP" -sc_threshold 0 )
  fi

  if [[ $VERBOSE -eq 1 ]]; then
    ffmpeg "${FFMPEG_INPUT_ARGS[@]}" "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)
  else
    ffmpeg "${FFMPEG_INPUT_ARGS[@]}" "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr >>"$LOGFILE")
  fi
  local exit_code=$?
  set -e
  return $exit_code
}

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Starting stream with re-encoding (forced)..."
  if run_ffmpeg_encode; then
    log "[pipr] Stream succeeded with re-encoding."
    exit 0
  else
    err "[pipr] ffmpeg failed with re-encoding. See $LOGFILE for details."
  fi
fi

log "[pipr] Attempting to stream using codec copy (-c copy)..."
if run_ffmpeg_copy; then
  log "[pipr] Stream succeeded with stream copy."
  exit 0
fi

log "[pipr] Codec copy failed. Retrying with re-encoding ($ENCODER/aac)..."
if run_ffmpeg_encode; then
  log "[pipr] Stream succeeded after re-encoding."
else
  err "[pipr] ffmpeg failed, even after re-encoding. See $LOGFILE for details."
fi
