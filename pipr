#!/usr/bin/env bash
# pipr: Pipe ANY supported livestream/video to an RTMP endpoint using yt-dlp and ffmpeg.
# Usage: pipr [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] <media_url> <rtmp_endpoint>
# Examples:
#   pipr "https://www.youtube.com/watch?v=XXXXX" "rtmp://your-endpoint/live/stream_key"
#   pipr --force-encoding --encoder libx264 --bitrate 4500k --preset veryfast "https://www.twitch.tv/<channel>" "rtmp://your-endpoint/live/key"
#   pipr -v --preset fast --encoder h264_nvenc "https://www.example.com/video" "rtmp://your-endpoint/live/key"

set -e

#####################
# Logging Functions #
#####################
LOGFILE="pipr.log"
log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "$LOGFILE"
}
err() {
  log "ERROR: $*"
  exit 1
}

################################
# Privacy/utility helper funcs #
################################
host_from_url() {
  # Prints only the host of a URL (scheme-agnostic)
  # Example: https://example.com/path?a=b -> example.com
  local url="$1"
  echo "$url" | sed -E 's~https?://([^/]+).*~\1~' | tr -d '\n'
}

mask_rtmp() {
  # Masks the last path segment (e.g., stream key) but keeps a short tail
  # Example: rtmp://server/app/abcdef123 -> rtmp://server/app/***e123
  local url="$1"
  local no_query="${url%%\?*}"
  local base="${no_query%/*}"
  local key="${no_query##*/}"
  if [[ -z "$key" || "$base" == "$no_query" ]]; then
    echo "${no_query%/}/***"
    return
  fi
  local tail=""
  if [[ ${#key} -gt 4 ]]; then
    tail="${key: -4}"
    echo "${base}/***${tail}"
  else
    echo "${base}/***"
  fi
}

################################
# Flags, Arguments and Defaults #
################################
VERBOSE=0
FORCE_ENCODING=0
ENCODER="libx264"
VBITRATE=""
PRESET="veryfast"

# Simple long-option parser
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v)
      VERBOSE=1; shift
      ;;
    --force-encoding)
      FORCE_ENCODING=1; shift
      ;;
    --encoder)
      [[ -n "${2-}" ]] || err "Missing value for $1"
      ENCODER="$2"; shift 2
      ;;
    --bitrate|--vb|--video-bitrate)
      [[ -n "${2-}" ]] || err "Missing value for $1"
      VBITRATE="$2"; shift 2
      ;;
    --preset)
      [[ -n "${2-}" ]] || err "Missing value for $1"
      PRESET="$2"; shift 2
      ;;
    --)
      shift; break
      ;;
    -* )
      err "Unknown option: $1"
      ;;
    *)
      break
      ;;
  esac
done

STREAM_URL="${1-}"
RTMP_ENDPOINT="${2-}"

if [[ -z "$STREAM_URL" || -z "$RTMP_ENDPOINT" ]]; then
  err "Usage: $0 [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] <media_url> <rtmp_endpoint>"
fi

for cmd in yt-dlp ffmpeg; do
  if ! command -v "$cmd" &>/dev/null; then
    err "Required command '$cmd' not found. Please install it."
  fi
done

###################################
# Identify source domain for log  #
###################################
DOMAIN="$(host_from_url "${STREAM_URL}")"
log "[pipr] Source domain detected: $DOMAIN"

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Force encoding enabled; stream copy attempt will be skipped."
fi
log "[pipr] Encoding settings: encoder=$ENCODER preset=$PRESET bitrate=${VBITRATE:-default}"

#####################
# Get direct URL    #
#####################
log "[pipr] Getting media stream URL from yt-dlp for: $DOMAIN"
if [[ $VERBOSE -eq 1 ]]; then
  MEDIA_URL=$(yt-dlp --no-playlist --get-url -f "best" "$STREAM_URL" 2> >(tee -a "$LOGFILE" >&2)) || err "[pipr] yt-dlp failed to get stream URL"
else
  MEDIA_URL=$(yt-dlp --no-playlist --get-url -f "best" "$STREAM_URL" 2>>"$LOGFILE") || err "[pipr] yt-dlp failed to get stream URL"
fi

MEDIA_HOST="$(host_from_url "$MEDIA_URL")"
MASKED_RTMP="$(mask_rtmp "$RTMP_ENDPOINT")"

log "[pipr] Resolved media host: $MEDIA_HOST"
log "[pipr] Streaming to RTMP endpoint: $MASKED_RTMP"

#########################################
# Streaming with ffmpeg + error fallback#
#########################################
# Build encode command (optionally include bitrate)
encode_cmd_common=(-hide_banner -analyzeduration 20M -probesize 100M -re -i "$MEDIA_URL" -c:v "$ENCODER" -preset "$PRESET" -c:a aac -f flv "$RTMP_ENDPOINT")
if [[ -n "$VBITRATE" ]]; then
  encode_cmd_common=(-hide_banner -analyzeduration 20M -probesize 100M -re -i "$MEDIA_URL" -c:v "$ENCODER" -preset "$PRESET" -b:v "$VBITRATE" -c:a aac -f flv "$RTMP_ENDPOINT")
fi

run_ffmpeg_copy() {
  if [[ $VERBOSE -eq 1 ]]; then
    set +e; set -o pipefail
    ffmpeg -hide_banner -analyzeduration 20M -probesize 100M -re -i "$MEDIA_URL" -c copy -f flv "$RTMP_ENDPOINT" 2> >(tee -a "$LOGFILE" >&2)
    local exit_code=${PIPESTATUS[0]}
    set +o pipefail; set -e
    return $exit_code
  else
    set +e
    ffmpeg -hide_banner -analyzeduration 20M -probesize 100M -re -i "$MEDIA_URL" -c copy -f flv "$RTMP_ENDPOINT" >>"$LOGFILE" 2>&1
    local exit_code=$?
    set -e
    return $exit_code
  fi
}

run_ffmpeg_encode() {
  if [[ $VERBOSE -eq 1 ]]; then
    set +e; set -o pipefail
    ffmpeg "${encode_cmd_common[@]}" 2> >(tee -a "$LOGFILE" >&2)
    local exit_code=${PIPESTATUS[0]}
    set +o pipefail; set -e
    return $exit_code
  else
    set +e
    ffmpeg "${encode_cmd_common[@]}" >>"$LOGFILE" 2>&1
    local exit_code=$?
    set -e
    return $exit_code
  fi
}

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Starting stream with re-encoding (forced)..."
  if run_ffmpeg_encode; then
    log "[pipr] Stream succeeded with re-encoding."
    exit 0
  else
    err "[pipr] ffmpeg failed with re-encoding. See $LOGFILE for details."
  fi
fi

log "[pipr] Attempting to stream using codec copy (-c copy)..."
if run_ffmpeg_copy; then
  log "[pipr] Stream succeeded with stream copy."
  exit 0
fi

log "[pipr] Codec copy failed. Retrying with re-encoding ($ENCODER/aac)..."
if run_ffmpeg_encode; then
  log "[pipr] Stream succeeded after re-encoding."
else
  err "[pipr] ffmpeg failed, even after re-encoding. See $LOGFILE for details."
}