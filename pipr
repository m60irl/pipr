#!/usr/bin/env bash
# pipr: Pipe ANY supported livestream/video to an RTMP endpoint using yt-dlp and ffmpeg.
# Usage:
#   pipr [-v] [--force-encoding] [--encoder <name>] [--bitrate <vbitrate>] [--preset <preset>] \
#        [--audio-bitrate <abitrate>] [--audio-rate <arate>] [--gop <frames>] \
#        [--keyframe-interval <seconds|frames>] [--fps <rate>] \
#        [--analyzeduration <value>] [--probesize <value>] \
#        [--ytdlp-format <fmt>] [--ytdlp-arg <arg> ...] \
#        "<source_url>" "<rtmp_endpoint>"
# Examples:
#   pipr "https://www.youtube.com/watch?v=XXXXX" "rtmp://your-endpoint/live/stream_key"
#   pipr --force-encoding --encoder libx264 --bitrate 4500k --preset veryfast \
#        "https://www.twitch.tv/<channel>" "rtmp://your-endpoint/live/key"
#   pipr -v --preset fast --encoder h264_nvenc --audio-bitrate 160k --audio-rate 48k \
#        --keyframe-interval 2s --fps 60 "https://www.example.com/video" "rtmp://your-endpoint/live/key"

set -euo pipefail -E

####################
# Script Version   #
####################
VERSION="0.2.0"

####################
# Exit Codes       #
####################
EXIT_YTDLP_FAIL=10
EXIT_NO_MEDIA_URLS=11
EXIT_COPY_FAIL=20
EXIT_ENCODE_FAIL=21
EXIT_PROBE_FAIL=22
EXIT_INVALID_ARGS=2

#####################
# Logging Functions #
#####################
LOGFILE="pipr.log"
ENABLE_LOGFILE=0

# Rotate log if it exceeds max size
rotate_log_if_needed() {
  if [[ $ENABLE_LOGFILE -eq 1 && -n "$LOG_MAX_SIZE" && -f "$LOGFILE" ]]; then
    # Parse size (e.g., 10M, 5000k)
    local max_bytes=0
    if [[ "$LOG_MAX_SIZE" =~ ^([0-9]+)([kKmMgG]?)$ ]]; then
      local num="${BASH_REMATCH[1]}"
      local suffix="${BASH_REMATCH[2]}"
      case "${suffix,,}" in
        k) max_bytes=$((num * 1024)) ;;
        m) max_bytes=$((num * 1024 * 1024)) ;;
        g) max_bytes=$((num * 1024 * 1024 * 1024)) ;;
        "") max_bytes=$num ;;
      esac
    fi
    
    if [[ $max_bytes -gt 0 ]]; then
      local current_size
      current_size=$(stat -f%z "$LOGFILE" 2>/dev/null || stat -c%s "$LOGFILE" 2>/dev/null || echo 0)
      if [[ $current_size -ge $max_bytes ]]; then
        # Rotate: keep last 3 logs
        [[ -f "${LOGFILE}.2" ]] && rm -f "${LOGFILE}.2"
        [[ -f "${LOGFILE}.1" ]] && mv "${LOGFILE}.1" "${LOGFILE}.2"
        mv "$LOGFILE" "${LOGFILE}.1"
        echo "$(date '+%Y-%m-%d %H:%M:%S') [pipr] Log rotated (size: ${current_size} bytes, max: ${max_bytes} bytes)" > "$LOGFILE"
      fi
    fi
  fi
}

log() {
  rotate_log_if_needed
  if [[ $ENABLE_LOGFILE -eq 1 ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "$LOGFILE"
  else
    echo "$(date '+%Y-%m-%d %H:%M:%S') $*"
  fi
}
err() {
  local exit_code=1
  if [[ "$1" =~ ^[0-9]+$ ]]; then
    exit_code="$1"
    shift
  fi
  log "ERROR: $*"
  exit "$exit_code"
}

#########################
# Bash Version Detection #
#########################
BASH_LT4=0
if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  # shellcheck disable=SC2034  # BASH_LT4 is intentionally informational
  BASH_LT4=1
  log "[pipr] Warning: running on Bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} (<4). Using compatibility path for URL collection. Consider installing newer Bash."
fi

###################
# Error & Signal Handling #
###################
handle_error() {
  local exit_code=$?
  local line_no=$1
  log "ERROR: Command failed at line $line_no with exit code $exit_code"
  exit "$exit_code"
}

handle_shutdown() {
  local sig=$1
  log "[pipr] Caught signal $sig, shutting down..."
  # Disable traps to prevent recursion
  trap - INT TERM ERR
  # Kill all processes in the current process group
  kill 0 2>/dev/null || true
  exit 1
}

trap 'handle_error $LINENO' ERR
trap 'handle_shutdown INT' INT
trap 'handle_shutdown TERM' TERM

################################
# Privacy/utility helper funcs #
################################
host_from_url() {
  # Prints only the host of a URL (scheme-agnostic)
  # Example: https://example.com/path?a=b -> example.com
  local url="$1"
  echo "$url" | sed -E 's~https?://([^/]+).*~\1~' | tr -d '\n'
}

mask_rtmp() {
  # Masks the last path segment (e.g., stream key) but keeps a short tail
  # Example: rtmp://server/app/abcdef123 -> rtmp://server/app/***e123
  local url="$1"
  local no_query="${url%%\?*}"
  local base="${no_query%/*}"
  local key="${no_query##*/}"
  if [[ -z "$key" || "$base" == "$no_query" ]]; then
    echo "${no_query%/}/***"
    return
  fi
  local tail=""
  if [[ ${#key} -gt 4 ]]; then
    tail="${key: -4}"
    echo "${base}/***${tail}"
  else
    echo "${base}/***"
  fi
}

# Sanitize tool stderr by masking RTMP endpoints and reducing HTTP(S) URLs to host-only
# Handles trailing quotes/punctuation so the masked output looks natural.
filter_stderr() {
  while IFS= read -r line; do
    local out="$line"
    while read -r token; do
      [[ -z "$token" ]] && continue
      local url="$token"
      # Trim common trailing punctuation and quotes from token to get the raw URL
      while :; do
        case "$url" in
          *[\"\']|*\)|*\]|*\>|*.|*\;|*:|*,) url="${url%?}" ;;
          *) break ;;
        esac
      done
      [[ -z "$url" ]] && continue
      local replacement=""
      if [[ "$url" =~ ^rtmps?:// ]]; then
        replacement="$(mask_rtmp "$url")"
      elif [[ "$url" =~ ^https?:// ]]; then
        local proto host
        proto="${url%%://*}"
        host="$(host_from_url "$url")"
        replacement="${proto}://${host}/..."
      fi
      if [[ -n "$replacement" ]]; then
        out=${out//"$url"/"$replacement"}
      fi
    done < <(grep -Eo '((rtmps?|https?)://[^[:space:]]+)' <<<"$line" || true)
    echo "$out"
  done
}

# Check if ffmpeg supports http_persistent flag
supports_http_persistent() {
  if ffmpeg -h protocol=http 2>&1 | grep -q "http_persistent"; then
    echo 1
  else
    echo 0
  fi
}

# Probe a media stream to extract codec and format info
probe_stream() {
  local url="$1"
  local stream_type="${2:-v}"  # v for video, a for audio
  
  if ! command -v ffprobe &>/dev/null; then
    echo "probe_failed=1"
    return 1
  fi
  
  local select_stream
  if [[ "$stream_type" == "v" ]]; then
    select_stream="v:0"
  else
    select_stream="a:0"
  fi
  
  # Run ffprobe with error suppression
  local probe_output
  probe_output=$(ffprobe -v error -select_streams "$select_stream" \
    -show_entries stream=codec_name,width,height,avg_frame_rate,bit_rate,channels,sample_rate \
    -of default=noprint_wrappers=1 "$url" 2>/dev/null)
  
  if [[ -z "$probe_output" ]]; then
    echo "probe_failed=1"
    return 1
  fi
  
  # Parse output into key=value format
  local codec_name="" width="" height="" fps="" bitrate="" channels="" sample_rate=""
  while IFS='=' read -r key value; do
    case "$key" in
      codec_name) codec_name="$value" ;;
      width) width="$value" ;;
      height) height="$value" ;;
      avg_frame_rate) 
        # Convert fraction to decimal (e.g., 30000/1001 -> 29.97)
        if [[ "$value" =~ ^([0-9]+)/([0-9]+)$ ]]; then
          local num="${BASH_REMATCH[1]}"
          local den="${BASH_REMATCH[2]}"
          if command -v awk &>/dev/null; then
            fps=$(awk -v n="$num" -v d="$den" 'BEGIN{printf "%.2f", n/d}')
          else
            fps="$value"
          fi
        else
          fps="$value"
        fi
        ;;
      bit_rate) bitrate="$value" ;;
      channels) channels="$value" ;;
      sample_rate) sample_rate="$value" ;;
    esac
  done <<< "$probe_output"
  
  # Return key=value pairs
  if [[ "$stream_type" == "v" ]]; then
    echo "codec=$codec_name width=$width height=$height fps=$fps bitrate=${bitrate:-unknown}"
  else
    echo "codec=$codec_name channels=$channels sample_rate=$sample_rate"
  fi
  return 0
}

# Parse bitrate string (e.g., 4500k, 5M) to numeric value in kbps
parse_bitrate() {
  local br="$1"
  if [[ "$br" =~ ^([0-9]+)([kKmM]?)$ ]]; then
    local num="${BASH_REMATCH[1]}"
    local suffix="${BASH_REMATCH[2]}"
    case "${suffix,,}" in
      k) echo "$num" ;;
      m) echo "$((num * 1000))" ;;
      "") echo "$num" ;;
    esac
  else
    echo ""
  fi
}

###############################
# Flags, Arguments and Defaults#
###############################
VERBOSE=0
DRY_RUN=0
FORCE_ENCODING=0
ENCODER="libx264"
VBITRATE=""
PRESET="veryfast"
ABITRATE=""   # e.g., 128k, 160k
ARATE=""      # e.g., 44100, 48k
GOP=""        # keyframe interval in frames
KEYINT=""     # keyframe interval in seconds (e.g., 2s) or frames (e.g., 120)
FPS=""        # optional, used to align -g with seconds-based keyframe interval
ANALYZEDURATION="20M"
PROBESIZE="100M"
LOG_MAX_SIZE=""  # e.g., 10M for log rotation

# New flags
REALTIME=0
PROPAGATE_HEADERS=0

# yt-dlp pass-through support
YTDLP_ARGS=()
YTDLP_FORMAT=""  # Will be set to default if not provided by user
DEFAULT_FORMAT='bestvideo[ext=mp4][vcodec^=avc1]+bestaudio[ext=m4a]/best[ext=mp4][vcodec^=avc1]/best'

print_help() {
  cat <<EOF
pipr v${VERSION} - Pipe any video/livestream to RTMP using yt-dlp and ffmpeg

Usage:
  pipr [OPTIONS] "<source_url>" "<rtmp_endpoint>"

Core Flags:
  -v, --verbose              Verbose mode; show ffmpeg progress and mirror tool output to terminal.
  --dry-run                  Extract and probe media, print planned mode and commands, then exit without streaming.
  --force-encoding           Skip stream copy attempt and start with re-encoding.

Encoding Flags:
  --encoder <name>           Video encoder for re-encode (default: libx264).
                             Examples: libx264, h264_nvenc, hevc_videotoolbox.
  --bitrate <vbitrate>       Video bitrate for re-encode (e.g., 4500k, 5M). Default: encoder default.
  --preset <preset>          Encoder preset (default: veryfast). Examples: veryfast, fast, medium.
  --audio-bitrate <abitrate> Audio bitrate (e.g., 128k, 160k). Default: encoder default.
  --audio-rate <arate>       Audio sample rate (e.g., 44100, 48k). Default: source/default.
  --keyframe-interval <v>    Keyframe interval in seconds (e.g., 2s) or frames (e.g., 120). Overrides --gop.
  --fps <rate>               When using seconds-based interval, also set -g = seconds*fps.
  --gop <frames>             GOP size (keyframe interval in frames). Applies -g and -sc_threshold 0.

Extraction Flags:
  --ytdlp-format <fmt>       yt-dlp format selector.
                             Default: bestvideo[ext=mp4][vcodec^=avc1]+bestaudio[ext=m4a]/best[ext=mp4][vcodec^=avc1]/best
  --ytdlp-arg <arg>          Additional yt-dlp argument (repeatable).
                             Example: --ytdlp-arg "--cookies cookies.txt"

Buffer/Network Flags:
  --analyzeduration <value>  ffmpeg analyzeduration (default: 20M).
  --probesize <value>        ffmpeg probesize (default: 100M).
  --realtime                 Apply real-time pacing (-re) to HTTP/HTTPS inputs for VOD-to-RTMP streaming.
  --propagate-headers        Fetch and forward yt-dlp HTTP headers to ffmpeg (requires jq).

Logging:
  --log [<path>]             Enable file logging. Optionally specify log file path (default: pipr.log).
  --log-max-size <size>      Max log size before rotation (e.g., 10M). Requires --log to be enabled.

Misc:
  -h, --help                 Show this help and exit.
  --version                  Show version and exit.

Notes:
  - File logging is OFF by default. Use --log to enable.
  - By default (no -v), ffmpeg runs quietly (errors only). Use -v to see progress.
  - Copy is attempted first unless --force-encoding or --dry-run is set.
  - If copy fails, re-encoding is used with the above settings.
  - Logs sanitize RTMP endpoints and reduce HTTP(S) URLs to host-only.

Examples:
  # Basic usage (copy first, fallback to encode):
  pipr "https://www.youtube.com/watch?v=XXX" "rtmp://server/live/key"

  # Dry run to see what would be done:
  pipr --dry-run -v "https://www.youtube.com/watch?v=XXX" "rtmp://server/live/key"

  # Force encoding with custom settings:
  pipr --force-encoding --encoder libx264 --bitrate 4500k --preset fast \\
       --keyframe-interval 2s --fps 60 "https://..." "rtmp://..."

  # With logging and rotation:
  pipr --log /tmp/stream.log --log-max-size 10M "https://..." "rtmp://..."
EOF
}

# Simple long-option parser
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--verbose) VERBOSE=1; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    --force-encoding) FORCE_ENCODING=1; shift ;;
    --encoder) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; ENCODER="$2"; shift 2 ;;
    --bitrate|--vb|--video-bitrate) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; VBITRATE="$2"; shift 2 ;;
    --preset) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; PRESET="$2"; shift 2 ;;
    --audio-bitrate|--ab) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; ABITRATE="$2"; shift 2 ;;
    --audio-rate|--ar) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; ARATE="$2"; shift 2 ;;
    --gop) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; GOP="$2"; shift 2 ;;
    --keyframe-interval|--keyint) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; KEYINT="$2"; shift 2 ;;
    --fps) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; FPS="$2"; shift 2 ;;
    --analyzeduration) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; ANALYZEDURATION="$2"; shift 2 ;;
    --probesize) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; PROBESIZE="$2"; shift 2 ;;
    --ytdlp-arg) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; YTDLP_ARGS+=( "$2" ); shift 2 ;;
    --ytdlp-format) [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"; YTDLP_FORMAT="$2"; shift 2 ;;
    --realtime) REALTIME=1; shift ;;
    --propagate-headers) PROPAGATE_HEADERS=1; shift ;;
    --log-file|--log)
      ENABLE_LOGFILE=1
      if [[ -n "${2-}" && ! "$2" =~ ^- ]]; then
        LOGFILE="$2"
        shift 2
      else
        shift
      fi
      ;;
    --log-max-size)
      [[ -n "${2-}" ]] || err "$EXIT_INVALID_ARGS" "Missing value for $1"
      LOG_MAX_SIZE="$2"
      shift 2
      ;;
    --no-log-file) ENABLE_LOGFILE=0; shift ;;
    -h|--help) print_help; exit 0 ;;
    --version) echo "pipr v${VERSION}"; exit 0 ;;
    --) shift; break ;;
    -*) err "$EXIT_INVALID_ARGS" "Unknown option: $1" ;;
    *) break ;;
  esac
done

STREAM_URL="${1-}"
RTMP_ENDPOINT="${2-}"

if [[ -z "$STREAM_URL" || -z "$RTMP_ENDPOINT" ]]; then
  err "$EXIT_INVALID_ARGS" "Missing required arguments. Run 'pipr --help' for usage."
fi

# Apply default format if user did not provide one
if [[ -z "$YTDLP_FORMAT" ]]; then
  YTDLP_FORMAT="$DEFAULT_FORMAT"
fi

for cmd in yt-dlp ffmpeg; do
  if ! command -v "$cmd" &>/dev/null; then
    err "$EXIT_INVALID_ARGS" "Required command '$cmd' not found. Please install it."
  fi
done

###################################
# Preflight: Log tool versions     #
###################################
log "[pipr] Tool versions:"
if command -v yt-dlp &>/dev/null; then
  YTDLP_VER=$(yt-dlp --version 2>/dev/null || echo "unknown")
  log "[pipr]   yt-dlp: $YTDLP_VER"
fi
if command -v ffmpeg &>/dev/null; then
  FFMPEG_VER=$(ffmpeg -version 2>/dev/null | head -n1 || echo "unknown")
  log "[pipr]   ffmpeg: $FFMPEG_VER"
fi

log "[pipr] yt-dlp format string: $YTDLP_FORMAT"

# Check rtmps support if endpoint uses rtmps://
if [[ "$RTMP_ENDPOINT" =~ ^rtmps:// ]]; then
  if ! ffmpeg -hide_banner -protocols 2>&1 | grep -qw "rtmps"; then
    log "[pipr] WARNING: RTMP endpoint uses rtmps:// but ffmpeg does not list 'rtmps' in supported protocols. This may fail. Consider using an ffmpeg build with TLS support."
  fi
fi

###################################
# Identify source domain for log  #
###################################
DOMAIN="$(host_from_url "$STREAM_URL")"
log "[pipr] Source domain detected: $DOMAIN"

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Force encoding enabled; stream copy attempt will be skipped."
fi
log "[pipr] Encoding settings: encoder=$ENCODER preset=$PRESET vbitrate=${VBITRATE:-default} abitrate=${ABITRATE:-default} arate=${ARATE:-default} gop=${GOP:-default} keyint=${KEYINT:-default} fps=${FPS:-default}"
log "[pipr] Buffering: analyzeduration=$ANALYZEDURATION probesize=$PROBESIZE"

#######################
# Get direct URL       #
#######################
log "[pipr] Getting media stream URL from yt-dlp for: $DOMAIN"
if [[ $VERBOSE -eq 1 ]]; then
  if command -v mapfile &>/dev/null || command -v readarray &>/dev/null; then
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
    else
      mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr >&2)) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
    fi
  else
    # Bash 3.2 fallback: use while read loop with process substitution
    MEDIA_URLS=()
    while IFS= read -r line; do
      MEDIA_URLS+=("$line")
    done < <(
      if [[ $ENABLE_LOGFILE -eq 1 ]]; then
        yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)
      else
        yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr >&2)
      fi
    ) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
  fi
else
  if command -v mapfile &>/dev/null || command -v readarray &>/dev/null; then
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr >>"$LOGFILE")) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
    else
      mapfile -t MEDIA_URLS < <(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2>/dev/null) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
    fi
  else
    # Bash 3.2 fallback: use while read loop with process substitution
    MEDIA_URLS=()
    while IFS= read -r line; do
      MEDIA_URLS+=("$line")
    done < <(
      if [[ $ENABLE_LOGFILE -eq 1 ]]; then
        yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2> >(filter_stderr >>"$LOGFILE")
      else
        yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --get-url -f "$YTDLP_FORMAT" "$STREAM_URL" 2>/dev/null
      fi
    ) || err "$EXIT_YTDLP_FAIL" "[pipr] yt-dlp failed to get stream URL"
  fi
fi

if [[ ${#MEDIA_URLS[@]} -eq 0 ]]; then
  err "$EXIT_NO_MEDIA_URLS" "[pipr] No media URLs returned by yt-dlp"
fi

MEDIA_HOST="$(host_from_url "${MEDIA_URLS[0]}")"
MASKED_RTMP="$(mask_rtmp "$RTMP_ENDPOINT")"
log "[pipr] Resolved media host: $MEDIA_HOST"
log "[pipr] Streaming to RTMP endpoint: $MASKED_RTMP"

#########################################
# Preflight ffprobe probing             #
#########################################
PROBE_VIDEO_CODEC=""
PROBE_AUDIO_CODEC=""
PROBE_FAILED=0
SHOULD_COPY=0
DECISION_REASON=""

if [[ $DRY_RUN -eq 1 || $FORCE_ENCODING -eq 0 ]]; then
  log "[pipr] Preflight probing media streams..."
  
  # Probe first video URL
  if [[ ${#MEDIA_URLS[@]} -ge 1 ]]; then
    probe_result=$(probe_stream "${MEDIA_URLS[0]}" "v" 2>/dev/null || echo "probe_failed=1")
    if [[ "$probe_result" =~ probe_failed=1 ]]; then
      PROBE_FAILED=1
      log "[pipr] WARNING: ffprobe failed on video stream"
    else
      # Parse probe results
      for field in $probe_result; do
        if [[ "$field" =~ ^codec=(.+)$ ]]; then
          PROBE_VIDEO_CODEC="${BASH_REMATCH[1]}"
        fi
      done
      if [[ $VERBOSE -eq 1 ]]; then
        log "[pipr] Video probe: $probe_result"
      else
        log "[pipr] Video codec: ${PROBE_VIDEO_CODEC:-unknown}"
      fi
    fi
  fi
  
  # Probe audio URL (second URL if separate, or first URL if single)
  audio_url="${MEDIA_URLS[0]}"
  if [[ ${#MEDIA_URLS[@]} -ge 2 ]]; then
    audio_url="${MEDIA_URLS[1]}"
  fi
  
  probe_result=$(probe_stream "$audio_url" "a" 2>/dev/null || echo "probe_failed=1")
  if [[ "$probe_result" =~ probe_failed=1 ]]; then
    if [[ ${#MEDIA_URLS[@]} -ge 2 ]]; then
      log "[pipr] WARNING: ffprobe failed on audio stream"
    else
      log "[pipr] No audio stream detected (video-only)"
    fi
  else
    # Parse probe results
    for field in $probe_result; do
      if [[ "$field" =~ ^codec=(.+)$ ]]; then
        PROBE_AUDIO_CODEC="${BASH_REMATCH[1]}"
      fi
    done
    if [[ $VERBOSE -eq 1 ]]; then
      log "[pipr] Audio probe: $probe_result"
    else
      log "[pipr] Audio codec: ${PROBE_AUDIO_CODEC:-unknown}"
    fi
  fi
  
  # Decide copy viability
  if [[ $FORCE_ENCODING -eq 1 ]]; then
    SHOULD_COPY=0
    DECISION_REASON="forced encoding flag"
  elif [[ $DRY_RUN -eq 1 ]]; then
    SHOULD_COPY=0
    DECISION_REASON="dry-run mode"
  elif [[ $PROBE_FAILED -eq 1 ]]; then
    SHOULD_COPY=1  # Attempt copy on probe failure (legacy behavior)
    DECISION_REASON="probe failure fallback"
  else
    # Check codec compatibility
    video_ok=0
    audio_ok=0
    
    if [[ "$PROBE_VIDEO_CODEC" =~ ^(h264|avc1)$ ]]; then
      video_ok=1
    fi
    
    if [[ "$PROBE_AUDIO_CODEC" =~ ^(aac|mp4a)$ ]] || [[ -z "$PROBE_AUDIO_CODEC" ]]; then
      audio_ok=1
    fi
    
    if [[ $video_ok -eq 1 && $audio_ok -eq 1 ]]; then
      SHOULD_COPY=1
      DECISION_REASON="video=${PROBE_VIDEO_CODEC:-unknown}, audio=${PROBE_AUDIO_CODEC:-none}"
    else
      SHOULD_COPY=0
      if [[ $video_ok -eq 0 ]]; then
        DECISION_REASON="video codec=${PROBE_VIDEO_CODEC} not RTMP-compatible"
      elif [[ $audio_ok -eq 0 ]]; then
        DECISION_REASON="audio codec=${PROBE_AUDIO_CODEC} not RTMP-compatible"
      fi
    fi
  fi
  
  # Log decision
  if [[ $SHOULD_COPY -eq 1 ]]; then
    log "[pipr] Mode decision: COPY ($DECISION_REASON)"
  else
    log "[pipr] Mode decision: ENCODE (reason: $DECISION_REASON)"
  fi
fi

#########################################
# Optional: Propagate HTTP headers      #
#########################################
declare -A HTTP_HEADERS_ARGS
if [[ $PROPAGATE_HEADERS -eq 1 ]]; then
  if ! command -v jq &>/dev/null; then
    log "[pipr] WARNING: --propagate-headers requires jq, but jq is not installed. Skipping header propagation."
  else
    log "[pipr] Fetching HTTP headers from yt-dlp..."
    JSON_OUTPUT=$(yt-dlp --no-playlist "${YTDLP_ARGS[@]}" --dump-json -f "$YTDLP_FORMAT" "$STREAM_URL" 2>/dev/null || echo "{}")
    if [[ -n "$JSON_OUTPUT" && "$JSON_OUTPUT" != "{}" ]]; then
      # Extract http_headers if present
      USER_AGENT=$(echo "$JSON_OUTPUT" | jq -r '.http_headers["User-Agent"] // empty' 2>/dev/null || echo "")
      REFERER=$(echo "$JSON_OUTPUT" | jq -r '.http_headers["Referer"] // empty' 2>/dev/null || echo "")
      OTHER_HEADERS=$(echo "$JSON_OUTPUT" | jq -r '.http_headers | to_entries | map(select(.key != "User-Agent" and .key != "Referer")) | map("\(.key): \(.value)") | join("\r\n")' 2>/dev/null || echo "")
      
      # Build header args per URL (we'll apply them to HTTP(S) inputs)
      for idx in "${!MEDIA_URLS[@]}"; do
        url="${MEDIA_URLS[$idx]}"
        if [[ "$url" =~ ^https?:// ]]; then
          hargs=()
          if [[ -n "$USER_AGENT" ]]; then
            hargs+=( -user_agent "$USER_AGENT" )
          fi
          if [[ -n "$REFERER" ]]; then
            hargs+=( -referer "$REFERER" )
          fi
          if [[ -n "$OTHER_HEADERS" ]]; then
            hargs+=( -headers "${OTHER_HEADERS}"$'\r\n' )
          fi
          if [[ ${#hargs[@]} -gt 0 ]]; then
            HTTP_HEADERS_ARGS[$idx]="${hargs[*]}"
            log "[pipr] Propagated headers for input $idx"
          fi
        fi
      done
    else
      log "[pipr] WARNING: Could not fetch JSON metadata from yt-dlp. Skipping header propagation."
    fi
  fi
fi

#########################################
# Build input args (multi-URL handling) #
#########################################
# Build shared HTTP network flags       #
#########################################
HTTP_NET_FLAGS=( -reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 -rw_timeout 15000000 )
if [[ $(supports_http_persistent) -eq 1 ]]; then
  HTTP_NET_FLAGS+=( -http_persistent 0 )
fi

FFMPEG_INPUT_ARGS=(-hide_banner -analyzeduration "$ANALYZEDURATION" -probesize "$PROBESIZE")
MAP_ARGS=()
# Append per-input flags and -i
for idx in "${!MEDIA_URLS[@]}"; do
  url="${MEDIA_URLS[$idx]}"
  if [[ "$url" =~ ^https?:// ]]; then
    # HTTP/S input: add network resilience flags
    FFMPEG_INPUT_ARGS+=( "${HTTP_NET_FLAGS[@]}" )
    # Add real-time pacing if requested
    if [[ $REALTIME -eq 1 ]]; then
      FFMPEG_INPUT_ARGS+=( -re )
    fi
    # Add propagated headers if available
    if [[ -n "${HTTP_HEADERS_ARGS[$idx]:-}" ]]; then
      read -ra hargs_array <<< "${HTTP_HEADERS_ARGS[$idx]}"
      FFMPEG_INPUT_ARGS+=( "${hargs_array[@]}" )
    fi
  else
    # Non-HTTP input: apply -re to throttle reading
    FFMPEG_INPUT_ARGS+=( -re )
  fi
  # Add thread queue size before input
  FFMPEG_INPUT_ARGS+=( -thread_queue_size 1024 )
  FFMPEG_INPUT_ARGS+=( -i "$url" )
done

# Build stream mapping
if [[ ${#MEDIA_URLS[@]} -eq 1 ]]; then
  # Single input: map video and audio explicitly with optional audio
  MAP_ARGS+=( -map 0:v:0 -map 0:a:0? )
elif [[ ${#MEDIA_URLS[@]} -ge 2 ]]; then
  # Multi-input: map video from first, audio from second
  MAP_ARGS+=( -map 0:v:0 -map 1:a:0 )
fi

#########################################
# Streaming with ffmpeg + error fallback#
#########################################

# Helper function to build encode command args
build_encode_args() {
  local extra=()
  # Compatibility defaults for RTMP/FLV
  extra+=( -pix_fmt yuv420p -ac 2 )
  
  # Bitrate and audio tuning with improved rate control
  if [[ -n "$VBITRATE" ]]; then
    local bitrate_kbps
    bitrate_kbps=$(parse_bitrate "$VBITRATE")
    if [[ -n "$bitrate_kbps" ]]; then
      # Compute maxrate = 1.07 * bitrate, bufsize = 2 * bitrate
      local maxrate_kbps=$((bitrate_kbps * 107 / 100))
      local bufsize_kbps=$((bitrate_kbps * 2))
      extra+=( -b:v "${bitrate_kbps}k" -maxrate "${maxrate_kbps}k" -bufsize "${bufsize_kbps}k" )
    else
      # Fallback to old behavior if parsing fails
      extra+=( -b:v "$VBITRATE" -maxrate "$VBITRATE" -bufsize "$VBITRATE" )
    fi
  fi
  if [[ -n "$ABITRATE" ]]; then extra+=( -b:a "$ABITRATE" ); fi
  if [[ -n "$ARATE" ]]; then extra+=( -ar "$ARATE" ); fi
  
  # Encoder-specific tuning
  if [[ "$ENCODER" == "libx264" ]]; then
    extra+=( -profile:v high -tune zerolatency )
  elif [[ "$ENCODER" =~ nvenc ]]; then
    extra+=( -rc cbr -forced-idr 1 )
  fi
  
  # GOP / keyframe interval
  if [[ -n "$KEYINT" ]]; then
    local val="$KEYINT"
    if [[ "$val" =~ ^[0-9]+(\.[0-9]+)?s$ ]]; then
      local sec="${val%s}"
      extra+=( -sc_threshold 0 -force_key_frames "expr:gte(t,n_forced*${sec})" )
      if [[ -n "$FPS" && "$FPS" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        # Compute frames = round(sec * fps)
        local gframes=""
        if command -v awk &>/dev/null; then
          gframes=$(awk -v s="$sec" -v f="$FPS" 'BEGIN{printf "%d", s*f + 0.5}')
        else
          # Fallback: shell arithmetic for integer values only
          if [[ "$sec" =~ ^[0-9]+$ && "$FPS" =~ ^[0-9]+$ ]]; then
            gframes=$((sec * FPS))
          else
            log "[pipr] Warning: awk not found and values not integers; skipping -g computation"
          fi
        fi
        if [[ -n "$gframes" && "$gframes" -gt 0 ]]; then
          extra+=( -g "$gframes" -r "$FPS" -vsync cfr )
          # For libx264, add scenecut=0 to reinforce no scene-cut keyframes
          if [[ "$ENCODER" == "libx264" ]]; then
            extra+=( -x264-params "scenecut=0" )
          fi
        fi
      fi
    elif [[ "$val" =~ ^[0-9]+$ ]]; then
      extra+=( -g "$val" -sc_threshold 0 )
      # For libx264 with frame-based GOP, add scenecut=0
      if [[ "$ENCODER" == "libx264" ]]; then
        extra+=( -x264-params "scenecut=0" )
      fi
    else
      log "[pipr] Warning: invalid --keyframe-interval value '$val'; ignoring"
    fi
  elif [[ -n "$GOP" ]]; then
    extra+=( -g "$GOP" -sc_threshold 0 )
    # For libx264 with frame-based GOP, add scenecut=0
    if [[ "$ENCODER" == "libx264" ]]; then
      extra+=( -x264-params "scenecut=0" )
    fi
  fi
  
  echo "${extra[@]}"
}

# Dry-run mode: print planned commands and exit
if [[ $DRY_RUN -eq 1 ]]; then
  log "[pipr] DRY RUN MODE - Commands that would be executed:"
  log ""
  
  # Show copy command
  log "[pipr] Copy command (would be attempted first unless --force-encoding):"
  echo "  ffmpeg ${FFMPEG_INPUT_ARGS[*]} -loglevel info -stats -c copy ${MAP_ARGS[*]} -f flv \"$MASKED_RTMP\""
  log ""
  
  # Show encode command
  local encode_extra
  encode_extra=$(build_encode_args)
  log "[pipr] Encode command (fallback or if forced):"
  echo "  ffmpeg ${FFMPEG_INPUT_ARGS[*]} -loglevel info -stats ${MAP_ARGS[*]} -c:v $ENCODER -preset $PRESET -c:a aac $encode_extra -f flv \"$MASKED_RTMP\""
  log ""
  log "[pipr] Dry run complete. Exiting without streaming."
  exit 0
fi

run_ffmpeg_copy() {
  set +e
  if [[ $VERBOSE -eq 1 ]]; then
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel info -stats -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)
    else
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel info -stats -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 2> >(filter_stderr >&2)
    fi
  else
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel error -nostats -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr >>"$LOGFILE")
    else
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel error -nostats -c copy "${MAP_ARGS[@]}" -f flv "$RTMP_ENDPOINT" 2>/dev/null
    fi
  fi
  local exit_code=$?
  set -e
  return $exit_code
}

run_ffmpeg_encode() {
  set +e
  local encode_extra
  encode_extra=$(build_encode_args)
  read -ra extra <<< "$encode_extra"

  if [[ $VERBOSE -eq 1 ]]; then
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel info -stats "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr | tee -a "$LOGFILE" >&2)
    else
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel info -stats "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 2> >(filter_stderr >&2)
    fi
  else
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel error -nostats "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 1>>"$LOGFILE" 2> >(filter_stderr >>"$LOGFILE")
    else
      ffmpeg "${FFMPEG_INPUT_ARGS[@]}" -loglevel error -nostats "${MAP_ARGS[@]}" -c:v "$ENCODER" -preset "$PRESET" -c:a aac "${extra[@]}" -f flv "$RTMP_ENDPOINT" 2>/dev/null
    fi
  fi
  local exit_code=$?
  set -e
  return $exit_code
}

if [[ $FORCE_ENCODING -eq 1 ]]; then
  log "[pipr] Starting stream with re-encoding (forced)..."
  if run_ffmpeg_encode; then
    log "[pipr] Stream succeeded with re-encoding."
    exit 0
  else
    if [[ $ENABLE_LOGFILE -eq 1 ]]; then
      err "$EXIT_ENCODE_FAIL" "[pipr] ffmpeg failed with re-encoding. See $LOGFILE for details."
    else
      err "$EXIT_ENCODE_FAIL" "[pipr] ffmpeg failed with re-encoding. Run with -v to see error details."
    fi
  fi
fi

log "[pipr] Streaming using codec copy (-c copy)..."
if run_ffmpeg_copy; then
  log "[pipr] Stream succeeded with stream copy."
  exit 0
fi

# Copy failed, log fallback with exit code
copy_exit_code=$?
log "[pipr] Fallback: copy failed (exit=$copy_exit_code), switching to encode."

log "[pipr] Retrying with re-encoding ($ENCODER/aac)..."
if run_ffmpeg_encode; then
  log "[pipr] Stream succeeded after re-encoding."
else
  if [[ $ENABLE_LOGFILE -eq 1 ]]; then
    err "$EXIT_ENCODE_FAIL" "[pipr] ffmpeg failed, even after re-encoding. See $LOGFILE for details."
  else
    err "$EXIT_ENCODE_FAIL" "[pipr] ffmpeg failed, even after re-encoding. Run with -v to see error details."
  fi
fi
